---
title: 回溯？动归？
date: 2024-04-13 13:46:59
tags: xhs笔试复盘
---
小红书笔试写到一道回溯题，，来不及写了，故在这里写完康康（正确率18%
![粉丝数问题](../img/笔试/微信截图_20240413144759.png)
祭出我写了一半的回溯代码，，（也有动归的残骸

漏看了一条很重要的信息：只有一个账号能推广多次
（带摄像头的线上笔试真的太磨人了，，，屏幕比较小没放大根本看不见

当时想加个最小值的返回判定但是来不及编译了，，加上去应该正确率不止这么点，挺可惜的，，不过就算写了也没来得及考虑推广多次的情况
```cpp
#include<iostream>
using namespace std;
// int dp[101][101];
int a[100];
// 定义函数体
bool ddd(int bb,int x){
    if (x==0) return true;
    if (x<0||bb<0) return false;
    bool flag=0;
    for (int i=0;i<x;i++){
        int ii= a[i]/2;
        if (x>=ii){
            flag|=ddd(bb-1,x-ii);
        }
    }
    return flag;
}
int main(){
    // 感觉还是动态规划
    // 好像是回溯啊 那完蛋了

    // 第一个参数是最少需要推广几次
    // 第二个参数是现在的粉丝数量（这次推广之后
    int n,x;
    cin>>n>>x;
    for (int i=0;i<n;i++){
        cin>>a[i];
    }
    // for (int i=0;i<n;i++){
    //     int ii=a[i]/2;
    //     dp[1][a[i]/2]=1;
    // }
    bool flag=0;
    for (int i=1;i<=n;i++){
        if (ddd(i,x)){
            flag=true;
            cout<<i;
            system("pause");
            return 0;
        }
    }
    if (!flag){
        cout<<-1;
    }
    
    // cout<<flag;
    system("pause");
    return 0;
    
}
```


翻到了网上的解析，是用动归做的 因为我先做的下一题，，所以后来觉得这题不用动归做

```cpp
#include<iostream>
using namespace std;
int dp[101]; // 本来我想设二维的，但是发现一维就够了
// dp[x]表示粉丝数恰好为x时至少需要推广的次数
// 初值全都赋成INF_MAX
int a[100];// 输入的原账号的粉丝量
int t[100];// 每个账号推广后实际涨粉数（

int main(){
    
    int n,x;
    cin>>n>>x;
    for (int i=0;i<n;i++){
        cin>>a[i];
        t[i]=a[i]/2;
        // 这里就除以二 后面看着好看点
    }
    // 先考虑每个账号至多推广一次的情形
    for (int i=1;i<=x;i++){
        dp[i]=99999;
    }
    
    for (int i=0;i<n;i++){
        dp[t[i]]=1;
    }
    // bool flag=0;
    
    for (int i=1;i<=x;i++){
        for (int j=0;j<n;j++){
            if (i-t[j]>=0){
                dp[i]=min(dp[i],dp[i-t[j]]+1);
            }
            // 控制一下下标范围，当时太急了也没来得及写
            
        }
    }
    int tmp = dp[x];
    
    for (int i=0;i<n;i++){
        for (int j=1;j<=x;j++){
            dp[j]=99999;
        }
        t[i]=a[i];
        // dp[t[i]]=1;
        for (int j=0;j<n;j++){
            dp[t[j]]=1;
        }
        
        // 还有一个忽视了的点！题目问的是账号数不是推广的总次数
        // 所以这里推广多次的账号dp值不需要设成2
        
        
        for (int j=1;j<=x;j++){
            for (int m=0;m<n;m++){
                if (j>=t[m]){
                    dp[j]=min(dp[j],dp[j-t[m]]+1);
                }
                // 下标合法性
            }
        }
        t[i]=a[i]/2;
        // 回溯（bushi
        tmp = min(tmp,dp[x]);
    }
    if (dp[x]!=99999){
        cout<<dp[x];
    }
    else{
        cout<<-1;
    }
    // cout<<flag;
    system("pause");
    return 0;
    
}
```

输出了一下还是错，，比对了一下标准答案发现是因为重新初始化，所以把之前迭代的数据丢失了，缺失了只推广一半粉丝数的数据，，所以蝴蝶效应影响到了其他的dp值（和循环内外顺序以及++/--没有关系！

AC代码（应该AC了吧

```cpp
#include<iostream>
using namespace std;
int dp[101]; // 本来我想设二维的，但是发现一维就够了
// dp[x]表示粉丝数恰好为x时至少需要推广的次数
// 初值全都赋成INF_MAX
int a[100];// 输入的原账号的粉丝量
int t[100];// 每个账号推广后实际涨粉数（

int main(){
    
    int n,x;
    cin>>n>>x;
    for (int i=0;i<n;i++){
        cin>>a[i];
        t[i]=a[i]/2;
        // 这里就除以二 后面看着好看点
    }
    // 先考虑每个账号至多推广一次的情形
    for (int i=1;i<=x;i++){
        dp[i]=99999;
    }
    
    
    for (int i=0;i<n;i++){
        dp[t[i]]=1;
    }
    dp[0]=0;
    // bool flag=0;
    
    // for (int j=0;j<n;j++){
    //     for (int i=t[j];i<=x;i++){
    //         dp[i]=min(dp[i],dp[i-t[j]]+1);
    //     }
    // }
    for (int i=0;i<=x;i++){
        for (int j=0;j<n;j++){
            if (i>=t[j]){
                dp[i]=min(dp[i],dp[i-t[j]]+1);

            }
            
        }
    }
    
    
    int tmp = dp[x];
    
    for (int i=0;i<n;i++){
        // for (int j=1;j<=x;j++){
        //     dp[j]=99999;
        // }
        t[i]=a[i];
        // dp[t[i]]=1;
        // for (int j=0;j<n;j++){
        //     dp[t[j]]=1;
        // }
        // dp[0]=0;
        
        // 还有一个忽视了的点！题目问的是账号数不是推广的总次数
        // 所以这里推广多次的账号dp值不需要设成2
        
        
        // for (int m=0;m<n;m++){
        //     for (int j=t[m];j<=x;j++){
        //         dp[j]=min(dp[j],dp[j-t[m]]+1);
        //     }
        // }
        for (int j=0;j<=x;j++){
            for (int m=0;m<n;m++){
                if (j>=t[m]){
                    dp[j]=min(dp[j],dp[j-t[m]]+1);
                }
            }
        }
        
        

        t[i]=a[i]/2;
        // 回溯（bushi
        tmp = min(tmp,dp[x]);
    }
    if (dp[x]!=99999){
        cout<<dp[x];
    }
    else{
        cout<<-1;
    }
    // cout<<flag;
    system("pause");
    return 0;
    
}
```
再尝试下把回溯的方法补完，但是发现非常复杂，，gpt说这道题的最佳解法就是动态规划，回溯效率不高，，那就这样吧！

