---
title: 小米面试准备
date: 2024-04-10 12:45:29
tags:
---
感觉来不及准备了所以搞点高频考点突击一下。
# 线程与进程的区别
## my answer：
线程和别的线程共享一个地址空间？）每个进程有自己独立的地址空间
（用标准的角度讲应该属于拥有资源的角度
（其他忘了
## standard：
1. 调度：进程是**资源管理**的基本单位，线程是**程序执行**的基本单位。
2. 切换：线程上下文切换比进程上下文切换要快得多。
3. 拥有资源： 进程是拥有资源的一个独立单位，线程**不拥有系统资源，但是可以访问隶属于进程的资源**。
4. 系统开销： 创建或撤销进程时，系统都要为之**分配或回收系统资源**，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。

# 面向对象的三个特征
## my answer：
不会斯密达
## standard：
面向对象编程的三大特征是封装、继承和多态。

1. 封装：封装是指将数据和操作数据的方法（即函数）捆绑在一起，形成一个**类**。通过封装，我们可以**隐藏内部实现细节，只暴露必要的接口给外部使用**。这样可以提高代码的可维护性和安全性，并且方便其他开发者使用该类。

2. 继承：继承是指一个类可以**派生出子类**，子类会继承父类的属性和方法。通过继承，子类可以重用父类的代码，并且可以在不修改父类的情况下进行功能扩展。继承可以建立类之间的层次关系，使得代码更加灵活和可扩展。

3. 多态：多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。 那么在继承中要构成多态还有两个条件：必须通过基类的指针或者引用调用虚函数；被调用的函数必须是**虚函数**，且派生类必须对基类的虚函数进行重写.

# 介绍一下项目（操统）
因为每次应该都会问到所以感觉需要重点打磨。

结合一篇博客来重点作答一下（参考：博客园 MIT 6.S081 xv6调试不完全指北）

## 操统版
印象比较深刻的一个项目是MIT 6.S081对xv6的优化，其中有一个部分需要实现为每个新进程单独分配一个属于它的内核页。里面的细节非常多，debug起来也比较困难。比如说要在scheduler切换进程的时候, 刷新TLB和使用的虚拟-物理页表影射base，而且当控制权返回给调度器时，要切换为全局内核页表。这个点让我debug了很久。

### 可能延伸的问题
#### 咋debug的？
通过网上查阅操作系统的官方文档、技术论坛和社区的讨论，还有就是通过printf大法或者gdb调试。MIT 6.S081 2019提供的xv6采用的指令集是riscv，因此我们虚拟机上针对x86指令集的gdb可能无法较好的调试。我们需要用交叉编译工具来编译xv6，并用交叉编译工具提供的gdb来调试。

##### 关于gdb的延伸
通过-g调试命令，gdb可以监控pc（程序计数器）、sp（堆栈指针）、各类寄存器的值，结合ELF中的符号表，就可以将这些信息“翻译”为我们想要看的变量。比如说如果输入命令 file user/_sleep，其目的就是告诉gdb，加载_sleep的符号表，用它的符号表去解释你看到的东西。


##### printf一般print啥的延伸
1. **进程切换相关信息**：打印当前正在运行的进程ID，以及即将切换到的进程ID。这可以帮助确认进程切换逻辑是否按预期执行。

2. **页表信息**：打印页表的内容，包括虚拟地址到物理地址的映射情况，以及页表项的各种标志位（如是否有效、访问权限等）。这可以帮助确认进程切换时页表是否被正确更新。

3. **CPU寄存器状态**：打印CPU寄存器的当前状态，包括程序计数器（PC）、栈指针（SP）等。这可以帮助确定进程切换后CPU状态的正确性。

4. **内核空间的映射情况**：打印内核页表的内容，以及当前CPU的SATP寄存器的值（即当前使用的页表基地址）。这可以帮助确认内核空间的映射是否正确切换。

5. **TLB的状态**：打印TLB的内容，可以帮助确认TLB是否被正确刷新，以及新的地址映射是否已经生效。

6. **锁的获取和释放信息**：打印进程切换过程中获取和释放的锁，以及锁的持有情况。这可以帮助检查进程切换过程中的并发访问是否受到正确的同步保护。

7. **内存管理相关信息**：打印内存分配和释放的信息，以及内存池或内存区域的状态。这可以帮助确认内存管理功能是否按预期工作。
###### 怎么打印锁
在操作系统的源代码中，锁通常会定义为一个结构体，其中包含锁的状态和与锁相关的其他信息。锁的定义通常会包括锁的状态（如是否被持有）、持有锁的进程ID等信息。我们可以在锁的源代码中添加printf语句，以便打印锁的状态和其他信息。

下面是一个简单的示例，假设有一个名为`my_lock`的锁，它的内部结构定义如下：

```c
struct lock {
    int is_locked;
    int holding_pid;
    // 其他锁相关的信息
};

struct lock my_lock;
```

在需要打印锁信息的地方，可以添加类似以下的代码：

```c
printf("Lock status: %s\n", my_lock.is_locked ? "Locked" : "Unlocked");
if (my_lock.is_locked) {
    printf("Holding process ID: %d\n", my_lock.holding_pid);
}
```


#### 关于交叉编译的延伸
交叉编译是指在一个主机上为另一个不同体系结构的目标平台（通常是嵌入式系统或者其他类型的系统）编译软件。在交叉编译过程中，编译器、链接器和其他开发工具被配置为生成目标平台上可执行的代码，而不是在主机上运行的代码。

#### 关于riscv的延伸

RISC-V采用精简的指令集设计，只包含少量基本指令，并且设计为模块化的架构。它允许处理器设计者根据特定的应用需求选择添加适当的扩展，以实现更高级别的性能和功能，设计用于各种用途的计算机处理器，包括嵌入式系统、个人计算机、服务器和超级计算机等。它的设计理念是基于精简、模块化和可扩展的原则，旨在提供高性能、低功耗和可靠性。

可扩展性：RISC-V架构具有多个标准扩展，包括基本指令集（RV32I/RV64I）、乘法/除法扩展（M）、原子操作扩展（A）、浮点数扩展（F/D）、向量扩展（V）等。这些扩展允许处理器设计者根据需求选择添加额外的功能，例如浮点运算、向量计算等。