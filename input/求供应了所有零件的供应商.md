---
title: 求供应了所有零件的供应商
date: 2024-03-29 22:36:15
tags: 数据库
---
先复习一下关系代数里面的除法

学生表R：
| 学号 | 姓名 | 年龄 | 院系 |
| ------ | ------ | ------ | ------ |
| 001 | 张三 | 19 | 计算机 |

除数S1：

| 年龄 |
| ------ |
| 19 |

R÷S1=学生表中年龄为19的学生信息的新表格，但这个新表格中的字段不包括年龄。

即：
| 学号 | 姓名 | 院系 |
| ------ | ------ | ------ |
| 001 | 张三 | 计算机 |

所以除法结果就是在被除表中，同时满足除数表的所有条件，但没有除数表中的字段的新表（如果结果有多条记录要全部列出）。

言归正传，由于评测台的版本过于老，所以不支持except，只能搞where not exists嵌套

所以不妨来绕一下，供应了所有零件 = 不存在一个零件，它不在该供应商的供应零件集中，具体推导可以看下面图片
![回想起被数理逻辑支配的恐惧](../img/数据库/回想起被数理逻辑支配的恐惧.jpg)

一开始最里面的嵌套是用where not in写的，但是问了gpt之后说这样会导致一些空值的情况，所以最好还是用where not exists

```sql
SELECT SNAME
FROM S
WHERE NOT EXISTS (
    SELECT *
    FROM P
    WHERE NOT EXISTS (
        SELECT 1
        FROM SPJ
        WHERE SPJ.SNO = S.SNO
        AND SPJ.PNO = P.PNO
    )
)
```

SELECT 1是性能问题，它使得只要找到一条记录就返回结果。当然如果是为了考试的话用SELECT *也没有任何问题

可以将这段代码的执行思想类比为一个嵌套的循环，其中外部循环是对供应商的循环，内部循环是对零件的循环。这种思想类似于控制变量的概念，即在外部循环中保持一个变量不变（当前供应商），而在内部循环中迭代另一个变量（零件）。

1. 外部的 SELECT SNAME FROM S ... 查询遍历供应商表 S 中的每个供应商。
2. 对于每个供应商，内部的子查询开始执行。这个子查询对零件表 P 中的每个零件进行循环（通过 NOT EXISTS 子句），并检查是否存在至少一条记录，表示当前供应商供应该零件。如果不存在这样的记录，表示当前供应商缺少供应的零件。
3. 如果对于当前供应商不存在任何缺少供应的零件，即内部子查询返回空结果集，那么外部的 NOT EXISTS 就会返回 TRUE，表示当前供应商满足条件。
4. 如果对于当前供应商存在至少一种缺少供应的零件，那么外部的 NOT EXISTS 就会返回 FALSE，表示当前供应商不满足条件。

这种查询的执行方式确实类似于使用嵌套的循环来检查每个供应商是否满足条件。这样的查询结构有助于控制变量，以确保每个供应商都经过了正确的检查，而不会在内部循环中受到外部循环的影响（省流，类似于for循环控制外层变量在内层循环中不变，这样就能保证最内层的循环查找的一定是同一个供应商的供货记录

最外层的表是S，中间的是P，最内层的是SPJ