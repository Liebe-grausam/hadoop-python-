---
title: 金宇彬好笨
date: 2024-03-27 12:42:29
tags:
---
这个系列用来专门更数据库
![列出所有供应商的信息](../img/数据库/微信截图_20240327124313.png)
总的说来就是列出所有供应商的信息，包括供应商姓名、所供应的零件名（没有供应零件的供应商也要列出，最后结果中不要出现重复元组）

想实现的效果like this
![主要的痛点在于空行怎么实现](../img/数据库/fd6783cf6517e9620578fc548e54fa6.jpg)
在网上看到了一个用banbao搭博客的学长（姑且称他为banbao学长）的代码，但是运行之后是错误的
```
select distinct S.SNAME, P.PNAME
from S,SPJ,P
where S.SNO = SPJ.SNO and SPJ.PNO = P.PNO
```
还没从关系模型里一堆奇怪的符号转过弯来的我表示震惊，大致研究了一下，distinct可以去掉重复行，from的作用是笛卡尔积（不是自然连接！！！！！）where这行起到了自然连接的作用

笛卡尔积就是无脑乘起来（相当于小学的乘法法则 总共有a×b×c种

但是对于苯人贫瘠的脑子还是无法想象，于是我想起以前高中某信息代课老师笨笨的做法，以上表为例全部列了出来

![大力出奇迹](../img/数据库/大力出奇迹.jpg)

于是恍然大悟（模拟自然连接的筛选法则

所以学长的问题在于他没有实现空行，如何把空行揪出来呢

网上查询了一下（GPT），可以通过左外连接来实现这个需求。左外连接可以保证左边表（S 表）的所有记录都会被返回，即使它们在右边的表（这里是 SPJ 表）中没有匹配的记录。对于没有供应零件的供应商，其相关的零件名字段会返回为 NULL。

正确的代码如下：
```
SELECT DISTINCT S.SNAME, P.PNAME
FROM S
LEFT JOIN SPJ ON S.SNO = SPJ.SNO
LEFT JOIN P ON SPJ.PNO = P.PNO
```

和学长代码的主要区别就是把（伪）自然连接换成了左外连接！